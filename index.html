<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ratio de Série</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:16px; max-width:980px}
    h1{font-size:20px;margin:0 0 10px}
    .muted{color:#666; font-size:13px}
    .card{border:1px solid #ddd; border-radius:14px; padding:12px; margin:12px 0}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    input,button,select{font-size:16px; padding:10px; border:1px solid #ccc; border-radius:10px}
    button{cursor:pointer}
    table{border-collapse:collapse; width:100%}
    th,td{border:1px solid #e6e6e6; padding:8px; text-align:center}
    th{background:#f7f7f7; position:sticky; top:0}
    .danger{color:#b00020}
    .ok{color:#0b6b2a}
    label{font-size:13px; color:#333}
    .group{display:flex; flex-direction:column; gap:6px}
    .two{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    @media (max-width:900px){ .two{grid-template-columns:1fr} }
    .pill{display:inline-block; padding:6px 10px; border:1px solid #ddd; border-radius:999px; font-size:13px}
  </style>
</head>

<body>
  <h1>Calcul de séries par rouleaux</h1>
  <div class="muted">
    Tu saisis le stock. Tu choisis une couleur base + un nombre base (1 ou 2).
    L’auto calcule une <b>série réaliste</b> (petits nombres) selon les ratios du stock, puis l’app répète jusqu’à épuisement.
  </div>

  <div class="two">
    <div class="card">
      <h3 style="margin:0 0 10px">1) Stock (rouleaux)</h3>
      <div class="row">
        <button id="addStock" type="button">+ Ajouter couleur</button>
        <button id="clearAll" type="button" class="danger">Vider tout</button>
      </div>
      <div id="stockWrap" style="margin-top:10px"></div>
      <div class="muted">Astuce: évite les espaces dans les noms (ex: “BleuFoncé” ou “Bleu Foncé” mais reste cohérent).</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 10px">2) Patron (manuel + auto)</h3>

      <div class="row" style="margin-bottom:10px">
        <div class="group">
          <label>Couleur base (pour auto)</label>
          <select id="baseColor" style="min-width:220px"></select>
        </div>

        <div class="group">
          <label>Nombre base (1 / 2)</label>
          <input id="baseFactor" type="number" min="1" step="1" value="1" style="width:140px" />
        </div>

        <div class="group">
          <label>Max par couleur</label>
          <input id="maxPerColor" type="number" min="1" step="1" value="10" style="width:140px" />
        </div>

        <div class="group">
          <label>&nbsp;</label>
          <button id="autoFill" type="button">Auto-remplir patron</button>
        </div>
      </div>

      <div class="row" style="margin-bottom:10px">
        <button id="addPattern" type="button">+ Ajouter case au patron</button>
        <button id="copyStockToPattern" type="button">Copier stock → patron</button>
        <button id="clearPattern" type="button">Vider patron</button>
      </div>

      <div class="muted" style="margin:6px 0">
        <span class="pill">Manuel</span> : tu choisis la couleur (menu) + quantité.  
        <span class="pill">Auto</span> : calcule à partir des ratios stock/base pour obtenir une série “vendeuse”.
      </div>

      <div id="patternWrap"></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <button id="genAll" type="button">Calculer les séries</button>
      <button id="clearResults" type="button">Effacer résultats</button>
    </div>
    <div id="status" style="margin-top:10px"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Liste)</h3>
    <div id="list"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Tableau)</h3>
    <div style="overflow:auto">
      <table id="table"></table>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Reste final</h3>
    <div style="overflow:auto">
      <table id="restTable"></table>
    </div>
  </div>

<script>
  const $ = (id)=>document.getElementById(id);

  const state = {
    stock: [
      { name: "Noir", qty: 0 },
      { name: "Gris", qty: 0 },
      { name: "Kaki", qty: 0 },
      { name: "Beige", qty: 0 },
    ],
    pattern: [], // {name, qty}
    series: []
  };

  const clampInt = (v)=> Math.max(0, Math.floor(Number(v)||0));

  function normalize(){
    state.stock = (state.stock||[])
      .map(x=>({ name:(x.name||"").trim(), qty: clampInt(x.qty) }))
      .filter(x=>x.name.length>0);

    state.pattern = (state.pattern||[])
      .map(x=>({ name:(x.name||"").trim(), qty: clampInt(x.qty) }))
      .filter(x=>x.name.length>0 || x.qty>0);
  }

  function setStatus(msg, danger){
    $("status").innerHTML = `<span class="${danger ? "danger" : "ok"}">${msg}</span>`;
  }

  function totalObj(obj){
    return Object.values(obj).reduce((a,b)=>a+(Number(b)||0),0);
  }

  function totalPattern(){
    return state.pattern.reduce((a,x)=>a+(Number(x.qty)||0),0);
  }

  function stockNames(){
    return state.stock.map(s=>s.name).filter(Boolean);
  }

  function renderBaseSelector(){
    const sel = $("baseColor");
    const keep = sel.value || "";

    sel.innerHTML = "";
    const names = stockNames();

    if(names.length===0){
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Ajoute une couleur…";
      sel.appendChild(opt);
      return;
    }

    names.forEach(n=>{
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    });

    sel.value = names.includes(keep) ? keep : names[0];
  }

  function renderStock(){
    const wrap = $("stockWrap");
    wrap.innerHTML = "";

    state.stock.forEach((c,i)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.style.margin = "8px 0";

      const name = document.createElement("input");
      name.value = c.name;
      name.placeholder = "Couleur";
      name.style.width = "220px";
      name.onchange = ()=>{
        state.stock[i].name = name.value;
        normalize();
        renderAll(); // on rerend pour mettre à jour dropdowns
      };

      const qty = document.createElement("input");
      qty.type="number"; qty.min="0"; qty.step="1";
      qty.value = c.qty;
      qty.placeholder="Rouleaux";
      qty.style.width="160px";
      qty.onchange = ()=>{ state.stock[i].qty = qty.value; };

      const del = document.createElement("button");
      del.type="button";
      del.textContent="Supprimer";
      del.className="danger";
      del.onclick = ()=>{
        state.stock.splice(i,1);
        normalize();
        renderAll();
      };

      row.appendChild(name);
      row.appendChild(qty);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  // Patron: dropdown couleur (stock) + qty
  function renderPattern(){
    const wrap = $("patternWrap");
    wrap.innerHTML = "";

    const names = stockNames();

    if(state.pattern.length===0){
      wrap.innerHTML = `<div class="muted">Patron vide. Clique “Copier stock → patron” ou “+ Ajouter case au patron”.</div>`;
      return;
    }

    state.pattern.forEach((p,i)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.style.margin = "8px 0";

      const sel = document.createElement("select");
      sel.style.width = "220px";

      const optEmpty = document.createElement("option");
      optEmpty.value = "";
      optEmpty.textContent = "Choisir couleur…";
      sel.appendChild(optEmpty);

      names.forEach(n=>{
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        sel.appendChild(opt);
      });

      sel.value = names.includes(p.name) ? p.name : "";
      sel.onchange = ()=>{ state.pattern[i].name = sel.value; };

      const qty = document.createElement("input");
      qty.type="number"; qty.min="0"; qty.step="1";
      qty.value = p.qty;
      qty.placeholder="Par série";
      qty.style.width="160px";
      qty.onchange = ()=>{ state.pattern[i].qty = qty.value; };

      const del = document.createElement("button");
      del.type="button";
      del.textContent="Supprimer";
      del.className="danger";
      del.onclick = ()=>{
        state.pattern.splice(i,1);
        normalize();
        renderAll();
      };

      row.appendChild(sel);
      row.appendChild(qty);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  function copyStockToPattern(){
    normalize();
    const names = stockNames();
    state.pattern = names.map(n=>({name:n, qty:0}));
    renderAll();
    setStatus("Patron créé à partir du stock ✅ (quantités = 0)", false);
  }

  // ✅ NOUVELLE LOGIQUE AUTO (série réaliste)
  // base = 1 ou 2
  // patron[color] = round((stock[color] / stock[baseColor]) * base)
  // puis on plafonne à maxPerColor et au stock disponible.
  // La couleur base = base (plafonnée au stock base)
  function autoFillPattern(){
    normalize();
    const names = stockNames();
    if(names.length===0){
      setStatus("Ajoute au moins une couleur dans le stock.", true);
      return;
    }

    const baseColor = $("baseColor").value;
    const base = Math.max(1, Math.floor(Number($("baseFactor").value)||1));
    const maxPer = Math.max(1, Math.floor(Number($("maxPerColor").value)||10));

    const baseObj = state.stock.find(s=>s.name===baseColor);
    const baseStock = baseObj ? baseObj.qty : 0;

    if(baseStock <= 0){
      setStatus("La couleur base doit avoir un stock > 0.", true);
      return;
    }

    const active = state.stock.filter(s=>s.qty>0);

    // calc
    const pat = [];
    active.forEach(s=>{
      let q = 0;
      if(s.name === baseColor){
        q = base;
      } else {
        q = Math.round((s.qty / baseStock) * base);
      }

      // plafonds
      q = Math.min(q, maxPer);
      q = Math.min(q, s.qty);

      // IMPORTANT: on garde 0 possible (si ratio très faible)
      pat.push({name: s.name, qty: q});
    });

    // option: trier base en premier puis le reste (facile à lire)
    pat.sort((a,b)=>{
      if(a.name===baseColor) return -1;
      if(b.name===baseColor) return 1;
      return a.name.localeCompare(b.name);
    });

    state.pattern = pat;
    renderAll();
    setStatus(`Patron auto rempli ✅ (base ${baseColor} = ${base}, max/couleur=${maxPer})`, false);
  }

  function computeSeries(){
    normalize();
    state.series = [];

    if(state.pattern.length===0 || totalPattern()<=0){
      renderAll();
      setStatus("Patron vide (ou tout à 0). Remplis le patron ou clique Auto-remplir.", true);
      return;
    }

    // pas de ligne sans couleur si qty > 0
    const missing = state.pattern.filter(p=>!p.name && p.qty>0);
    if(missing.length){
      renderAll();
      setStatus("Patron: choisis une couleur pour chaque ligne (menu déroulant).", true);
      return;
    }

    // stock restant
    const rem = {};
    state.stock.forEach(s=> rem[s.name] = s.qty);

    // patron fixe
    const pat = {};
    state.pattern.forEach(p=>{
      if(p.name) pat[p.name] = clampInt(p.qty);
    });

    for(let guard=0; guard<20000; guard++){
      if(totalObj(rem)===0) break;

      const alloc = {};
      let tookAny = false;

      for(const [color, need0] of Object.entries(pat)){
        const need = clampInt(need0);
        if(need === 0) continue;

        const avail = rem[color] ?? 0;
        const take = Math.min(avail, need);

        alloc[color] = take;
        rem[color] = avail - take;

        if(take>0) tookAny = true;
      }

      // si le patron ne prend plus rien mais il reste du stock ailleurs => dernière série "reste"
      if(!tookAny){
        const last = {};
        for(const [c,q] of Object.entries(rem)){
          if(q>0){ last[c]=q; rem[c]=0; }
        }
        state.series.push({index: state.series.length+1, allocations:last});
        break;
      }

      state.series.push({index: state.series.length+1, allocations:alloc});
    }

    renderAll();
    setStatus(`Séries calculées ✅ (${state.series.length})`, false);
  }

  function allColorsUnion(){
    const set = new Set();
    state.stock.forEach(s=>set.add(s.name));
    state.pattern.forEach(p=>{ if(p.name) set.add(p.name); });
    state.series.forEach(sr=>Object.keys(sr.allocations||{}).forEach(k=>set.add(k)));
    return Array.from(set);
  }

  function renderList(){
    const el = $("list");
    if(state.series.length===0){
      el.innerHTML = `<div class="muted">Aucune série.</div>`;
      return;
    }
    el.innerHTML = state.series.map(sr=>{
      const parts = Object.entries(sr.allocations)
        .filter(([_,v])=> (Number(v)||0) > 0)
        .map(([k,v])=> `${k}: ${v}`)
        .join(" • ");
      const txt = parts.length ? parts : "<span class='muted'>Série vide</span>";
      return `<div style="margin:6px 0"><b>Série ${sr.index}</b> — ${txt}</div>`;
    }).join("");
  }

  function renderTable(){
    const t = $("table");
    if(state.series.length===0){
      t.innerHTML = `<tr><td class="muted">Aucune donnée.</td></tr>`;
      return;
    }
    const cols = allColorsUnion();
    let html = "<tr><th>Série</th>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "</tr>";

    state.series.forEach(sr=>{
      html += `<tr><td><b>${sr.index}</b></td>`;
      cols.forEach(c=>{
        html += `<td>${sr.allocations?.[c] ?? 0}</td>`;
      });
      html += "</tr>";
    });
    t.innerHTML = html;
  }

  function renderReste(){
    const rem = {};
    state.stock.forEach(s=> rem[s.name] = s.qty);
    state.series.forEach(sr=>{
      for(const [c,v] of Object.entries(sr.allocations||{})){
        rem[c] = Math.max(0, (rem[c]??0) - (Number(v)||0));
      }
    });

    const cols = allColorsUnion();
    const t = $("restTable");
    let html = "<tr>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "<th>Total</th></tr><tr>";
    cols.forEach(c=> html += `<td>${rem[c] ?? 0}</td>`);
    html += `<td><b>${totalObj(rem)}</b></td></tr>`;
    t.innerHTML = html;
  }

  function renderAll(){
    normalize();
    renderBaseSelector();
    renderStock();
    renderPattern();
    renderList();
    renderTable();
    renderReste();
  }

  // Handlers
  $("addStock").onclick = ()=>{
    state.stock.push({name:"", qty:0});
    renderAll();
  };

  $("clearAll").onclick = ()=>{
    state.stock = [];
    state.pattern = [];
    state.series = [];
    renderAll();
    setStatus("Tout vidé ✅", false);
  };

  $("addPattern").onclick = ()=>{
    state.pattern.push({name:"", qty:0});
    renderAll();
  };

  $("copyStockToPattern").onclick = ()=> copyStockToPattern();

  $("clearPattern").onclick = ()=>{
    state.pattern = [];
    renderAll();
    setStatus("Patron vidé ✅", false);
  };

  $("autoFill").onclick = ()=> autoFillPattern();

  $("genAll").onclick = ()=> computeSeries();

  $("clearResults").onclick = ()=>{
    state.series = [];
    renderAll();
    setStatus("Résultats effacés ✅", false);
  };

  // init
  renderAll();
</script>
</body>
</html>
