<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ratio de Série</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:16px; max-width:980px}
    h1{font-size:20px;margin:0 0 10px}
    .muted{color:#666; font-size:13px}
    .card{border:1px solid #ddd; border-radius:14px; padding:12px; margin:12px 0}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    input,button,select{font-size:16px; padding:10px; border:1px solid #ccc; border-radius:10px}
    button{cursor:pointer}
    table{border-collapse:collapse; width:100%}
    th,td{border:1px solid #e6e6e6; padding:8px; text-align:center}
    th{background:#f7f7f7; position:sticky; top:0}
    .danger{color:#b00020}
    .ok{color:#0b6b2a}
    label{font-size:13px; color:#333}
    .group{display:flex; flex-direction:column; gap:6px}
    .two{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    @media (max-width:900px){ .two{grid-template-columns:1fr} }
  </style>
</head>

<body>
  <h1>Calcul de séries par rouleaux</h1>
  <div class="muted">
    1) Saisis le stock. 2) Définis le patron (manuel ou auto). 3) Calcule les séries jusqu’à épuisement total.
    Si une couleur finit, on continue avec les autres. La dernière série peut être incomplète.
  </div>

  <div class="two">
    <div class="card">
      <h3 style="margin:0 0 10px">1) Stock (rouleaux)</h3>
      <div class="row">
        <button id="addStock">+ Ajouter couleur</button>
        <button id="clearAll" class="danger">Vider tout</button>
      </div>
      <div id="stockWrap" style="margin-top:10px"></div>
      <div class="muted">Ex: Noir = 12 signifie 12 rouleaux Noir.</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 10px">2) Patron de série (manuel + auto)</h3>

      <div class="row" style="margin-bottom:10px">
        <div class="group">
          <label>Couleur base (pour auto)</label>
          <select id="baseColor" style="min-width:240px"></select>
        </div>

        <div class="group">
          <label>Base x (1 / 2 / 3 ...)</label>
          <input id="baseFactor" type="number" min="1" step="1" value="1" style="width:140px" />
        </div>

        <div class="group">
          <label>&nbsp;</label>
          <button id="autoFill">Auto-remplir patron</button>
        </div>
      </div>

      <div class="row" style="margin-bottom:10px">
        <button id="addPattern">+ Ajouter ligne patron</button>
        <button id="copyStockToPattern">Copier stock → patron</button>
        <button id="clearPattern">Vider patron</button>
      </div>

      <div id="patternWrap"></div>

      <div class="muted" style="margin-top:8px">
        Le calcul utilise <b>exactement</b> le patron affiché. Les couleurs du patron sont choisies depuis le stock (menu déroulant).
      </div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <button id="genAll">Calculer les séries</button>
      <button id="clearResults">Effacer résultats</button>
    </div>
    <div id="status" style="margin-top:10px"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Liste)</h3>
    <div id="list"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Tableau)</h3>
    <div style="overflow:auto">
      <table id="table"></table>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Reste final</h3>
    <div style="overflow:auto">
      <table id="restTable"></table>
    </div>
  </div>

<script>
  const $ = (id)=>document.getElementById(id);

  // ✅ Pas d'historique: tout repart à zéro à chaque ouverture
  const state = {
    stock: [
      { name: "Noir", qty: 0 },
      { name: "Gris", qty: 0 },
      { name: "Kaki", qty: 0 },
      { name: "Beige", qty: 0 },
    ],
    pattern: [],   // {name, qty}
    series: []     // {index, allocations}
  };

  function clampInt(v){ return Math.max(0, Math.floor(Number(v)||0)); }

  function normalize(){
    state.stock = (state.stock||[])
      .map(x=>({ name:(x.name||"").trim(), qty: clampInt(x.qty) }))
      .filter(x=>x.name.length>0);

    state.pattern = (state.pattern||[])
      .map(x=>({ name:(x.name||"").trim(), qty: clampInt(x.qty) }))
      .filter(x=>x.name.length>0 || x.qty>0); // on garde lignes utiles
  }

  function setStatus(msg, danger){
    $("status").innerHTML = `<span class="${danger ? "danger" : "ok"}">${msg}</span>`;
  }

  function totalObj(obj){
    return Object.values(obj).reduce((a,b)=>a+(Number(b)||0),0);
  }

  function totalPattern(){
    return state.pattern.reduce((a,x)=>a+(Number(x.qty)||0),0);
  }

  function stockNames(){
    return state.stock.map(s=>s.name).filter(n=>n.length>0);
  }

  function renderBaseSelector(){
    const sel = $("baseColor");
    const keep = sel.value || "__AUTO__";

    sel.innerHTML = "";
    const optAuto = document.createElement("option");
    optAuto.value = "__AUTO__";
    optAuto.textContent = "Auto (couleur la plus faible > 0)";
    sel.appendChild(optAuto);

    stockNames().forEach(n=>{
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    });

    const values = Array.from(sel.options).map(o=>o.value);
    sel.value = values.includes(keep) ? keep : "__AUTO__";
  }

  function renderStock(){
    const wrap = $("stockWrap");
    wrap.innerHTML = "";

    state.stock.forEach((c,i)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.style.margin = "8px 0";

      const name = document.createElement("input");
      name.value = c.name;
      name.placeholder = "Couleur";
      name.style.width = "220px";
      name.oninput = ()=>{ state.stock[i].name = name.value; renderAll(); };

      const qty = document.createElement("input");
      qty.type="number"; qty.min="0"; qty.step="1";
      qty.value = c.qty;
      qty.placeholder="Rouleaux";
      qty.style.width="160px";
      qty.oninput = ()=>{ state.stock[i].qty = qty.value; };

      const del = document.createElement("button");
      del.textContent="Supprimer";
      del.className="danger";
      del.onclick = ()=>{
        state.stock.splice(i,1);
        normalize();
        renderAll();
      };

      row.appendChild(name);
      row.appendChild(qty);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  // ✅ Patron: couleur choisie via dropdown basé sur le stock
  function renderPattern(){
    const wrap = $("patternWrap");
    wrap.innerHTML = "";

    const names = stockNames();

    if(state.pattern.length===0){
      wrap.innerHTML = `<div class="muted">Patron vide. Clique “Copier stock → patron” ou “+ Ajouter ligne patron”.</div>`;
      return;
    }

    state.pattern.forEach((p,i)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.style.margin = "8px 0";

      const sel = document.createElement("select");
      sel.style.width = "220px";

      const optEmpty = document.createElement("option");
      optEmpty.value = "";
      optEmpty.textContent = "Choisir couleur…";
      sel.appendChild(optEmpty);

      names.forEach(n=>{
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        sel.appendChild(opt);
      });

      sel.value = names.includes(p.name) ? p.name : "";
      sel.onchange = ()=>{ state.pattern[i].name = sel.value; };

      const qty = document.createElement("input");
      qty.type="number"; qty.min="0"; qty.step="1";
      qty.value = p.qty;
      qty.placeholder="Par série";
      qty.style.width="160px";
      qty.oninput = ()=>{ state.pattern[i].qty = qty.value; };

      const del = document.createElement("button");
      del.textContent="Supprimer";
      del.className="danger";
      del.onclick = ()=>{
        state.pattern.splice(i,1);
        normalize();
        renderAll();
      };

      row.appendChild(sel);
      row.appendChild(qty);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  function copyStockToPattern(){
    normalize();
    const names = stockNames();
    state.pattern = names.map(n=>({name:n, qty:0}));
    renderAll();
    setStatus("Patron créé à partir du stock ✅ (quantités = 0)", false);
  }

  // ✅ Auto-remplir: cible = baseQty * factor, patron = min(stock, cible) pour chaque couleur active
  function autoFillPattern(){
    normalize();
    const factor = Math.max(1, Math.floor(Number($("baseFactor").value)||1));
    const baseChoice = $("baseColor").value;

    const active = state.stock.filter(s=>s.qty>0);
    if(active.length===0){
      setStatus("Ajoute au moins une couleur avec un stock > 0.", true);
      return;
    }

    let baseQty = 0;
    if(baseChoice === "__AUTO__"){
      baseQty = Math.min(...active.map(x=>x.qty));
    }else{
      const found = active.find(x=>x.name === baseChoice);
      if(!found){
        setStatus("Choisis une couleur base qui a un stock > 0, ou Auto.", true);
        return;
      }
      baseQty = found.qty;
    }

    const target = baseQty * factor;

    state.pattern = active.map(s=>({
      name: s.name,
      qty: Math.min(s.qty, target)
    }));

    renderAll();
    setStatus(`Patron auto rempli ✅ (cible = ${target})`, false);
  }

  function computeSeries(){
    normalize();
    state.series = [];

    if(state.pattern.length===0 || totalPattern()<=0){
      renderAll();
      setStatus("Patron vide (ou tout à 0). Remplis le patron ou clique Auto-remplir.", true);
      return;
    }

    // vérif: pas de lignes sans couleur
    const missing = state.pattern.filter(p=>!p.name && p.qty>0);
    if(missing.length){
      renderAll();
      setStatus("Patron: choisis une couleur pour chaque ligne (menu déroulant).", true);
      return;
    }

    // stock restant
    const rem = {};
    state.stock.forEach(s=> rem[s.name] = s.qty);

    // patron fixe (objet)
    const pat = {};
    state.pattern.forEach(p=>{
      if(p.name) pat[p.name] = Math.max(0, Math.floor(Number(p.qty)||0));
    });

    // boucle: on applique le patron, si une couleur est finie → take=0, et on continue
    for(let guard=0; guard<10000; guard++){
      if(totalObj(rem)===0) break;

      const alloc = {};
      let tookAny = false;

      for(const [color, need0] of Object.entries(pat)){
        const need = Math.max(0, Math.floor(Number(need0)||0));
        if(need === 0) continue;

        const avail = rem[color] ?? 0;
        const take = Math.min(avail, need);

        alloc[color] = take;
        rem[color] = avail - take;

        if(take>0) tookAny = true;
      }

      // si le patron ne prend plus rien mais il reste du stock ailleurs → dernière série "reste"
      if(!tookAny){
        const last = {};
        for(const [c,q] of Object.entries(rem)){
          if(q>0){ last[c]=q; rem[c]=0; }
        }
        state.series.push({index: state.series.length+1, allocations:last});
        break;
      }

      state.series.push({index: state.series.length+1, allocations:alloc});
    }

    renderAll();
    setStatus(`Séries calculées ✅ (${state.series.length})`, false);
  }

  function allColorsUnion(){
    const set = new Set();
    state.stock.forEach(s=>set.add(s.name));
    state.pattern.forEach(p=>{ if(p.name) set.add(p.name); });
    state.series.forEach(sr=>Object.keys(sr.allocations||{}).forEach(k=>set.add(k)));
    return Array.from(set);
  }

  function renderList(){
    const el = $("list");
    if(state.series.length===0){
      el.innerHTML = `<div class="muted">Aucune série.</div>`;
      return;
    }
    el.innerHTML = state.series.map(sr=>{
      const parts = Object.entries(sr.allocations)
        .filter(([_,v])=> (Number(v)||0) > 0)
        .map(([k,v])=> `${k}: ${v}`)
        .join(" • ");
      const txt = parts.length ? parts : "<span class='muted'>Série vide</span>";
      return `<div style="margin:6px 0"><b>Série ${sr.index}</b> — ${txt}</div>`;
    }).join("");
  }

  function renderTable(){
    const t = $("table");
    if(state.series.length===0){
      t.innerHTML = `<tr><td class="muted">Aucune donnée.</td></tr>`;
      return;
    }
    const cols = allColorsUnion();
    let html = "<tr><th>Série</th>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "</tr>";

    state.series.forEach(sr=>{
      html += `<tr><td><b>${sr.index}</b></td>`;
      cols.forEach(c=>{
        html += `<td>${sr.allocations?.[c] ?? 0}</td>`;
      });
      html += "</tr>";
    });
    t.innerHTML = html;
  }

  function renderReste(){
    const rem = {};
    state.stock.forEach(s=> rem[s.name] = s.qty);
    state.series.forEach(sr=>{
      for(const [c,v] of Object.entries(sr.allocations||{})){
        rem[c] = Math.max(0, (rem[c]??0) - (Number(v)||0));
      }
    });

    const cols = allColorsUnion();
    const t = $("restTable");
    let html = "<tr>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "<th>Total</th></tr><tr>";
    cols.forEach(c=> html += `<td>${rem[c] ?? 0}</td>`);
    html += `<td><b>${totalObj(rem)}</b></td></tr>`;
    t.innerHTML = html;
  }

  function renderAll(){
    normalize();
    renderBaseSelector();
    renderStock();
    renderPattern();
    renderList();
    renderTable();
    renderReste();
  }

  // UI handlers
  $("addStock").onclick = ()=>{
    state.stock.push({name:"", qty:0});
    renderAll();
  };

  $("clearAll").onclick = ()=>{
    state.stock = [];
    state.pattern = [];
    state.series = [];
    renderAll();
    setStatus("Tout vidé ✅", false);
  };

  $("addPattern").onclick = ()=>{
    state.pattern.push({name:"", qty:0});
    renderAll();
  };

  $("copyStockToPattern").onclick = ()=> copyStockToPattern();

  $("clearPattern").onclick = ()=>{
    state.pattern = [];
    renderAll();
    setStatus("Patron vidé ✅", false);
  };

  $("autoFill").onclick = ()=> autoFillPattern();

  $("genAll").onclick = ()=> computeSeries();

  $("clearResults").onclick = ()=>{
    state.series = [];
    renderAll();
    setStatus("Résultats effacés ✅", false);
  };

  // init
  renderAll();
</script>
</body>
</html>
