<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Séries Rouleaux</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:16px; max-width:980px}
    h1{font-size:20px;margin:0 0 10px}
    .muted{color:#666; font-size:13px}
    .card{border:1px solid #ddd; border-radius:14px; padding:12px; margin:12px 0}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    input,button{font-size:16px; padding:10px; border:1px solid #ccc; border-radius:10px}
    button{cursor:pointer}
    table{border-collapse:collapse; width:100%}
    th,td{border:1px solid #e6e6e6; padding:8px; text-align:center}
    th{background:#f7f7f7; position:sticky; top:0}
    .danger{color:#b00020}
    .ok{color:#0b6b2a}
    .two{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    @media (max-width:900px){ .two{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <h1>Calcul de séries par rouleaux</h1>
  <div class="muted">
    Tu saisis le stock (rouleaux) + le patron de série (quantité par série). L’app répète le patron jusqu’à épuisement total,
    même si la dernière série est incomplète (ex: 3 couleurs).
  </div>

  <div class="two">
    <div class="card">
      <h3 style="margin:0 0 10px">1) Stock (rouleaux)</h3>
      <div class="row">
        <button id="addStock">+ Ajouter couleur</button>
        <button id="save">Enregistrer</button>
        <button id="reset" class="danger">Reset</button>
      </div>
      <div id="stockWrap" style="margin-top:10px"></div>
      <div class="muted">Ex: Noir = 12 signifie 12 rouleaux Noir.</div>
    </div>

    <div class="card">
      <h3 style="margin:0 0 10px">2) Patron de série (par série)</h3>
      <div class="muted" style="margin-bottom:10px">
        Mets combien de rouleaux de chaque couleur doit contenir <b>UNE</b> série (ex: Noir 5, Gris 5, Kaki 3, Beige 3).
      </div>
      <div id="patternWrap"></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <button id="genAll">Générer toutes les séries</button>
      <button id="clear">Effacer résultats</button>
    </div>
    <div id="status" style="margin-top:10px"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Liste)</h3>
    <div id="list"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Tableau)</h3>
    <div style="overflow:auto">
      <table id="table"></table>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Reste final</h3>
    <div style="overflow:auto">
      <table id="restTable"></table>
    </div>
  </div>

<script>
  const $ = (id)=>document.getElementById(id);

  const state = {
    // stock: rouleaux dispo
    stock: [
      { name: "Noir", qty: 12 },
      { name: "Gris", qty: 7 },
      { name: "Kaki", qty: 3 },
      { name: "Beige", qty: 20 },
      { name: "Bordeaux", qty: 0 },
    ],
    // pattern: rouleaux par série (patron)
    pattern: {
      "Noir": 5,
      "Gris": 5,
      "Kaki": 3,
      "Beige": 3,
      "Bordeaux": 0
    },
    series: [] // {index, allocations:{color: qtyTaken}}
  };

  function load(){
    const raw = localStorage.getItem("series_rouleaux_v1");
    if(!raw) return;
    try{
      const p = JSON.parse(raw);
      if(p?.stock) state.stock = p.stock;
      if(p?.pattern) state.pattern = p.pattern;
      if(Array.isArray(p?.series)) state.series = p.series;
    }catch(e){}
  }
  function save(){
    localStorage.setItem("series_rouleaux_v1", JSON.stringify({
      stock: state.stock,
      pattern: state.pattern,
      series: state.series
    }));
  }

  function normalize(){
    state.stock = (state.stock||[])
      .map(x=>({ name:(x.name||"").trim(), qty: Math.max(0, Math.floor(Number(x.qty)||0)) }))
      .filter(x=>x.name.length>0);

    // garder pattern uniquement pour les couleurs existantes
    const next = {};
    state.stock.forEach(s=>{
      next[s.name] = Math.max(0, Math.floor(Number(state.pattern?.[s.name])||0));
    });
    state.pattern = next;
  }

  function setStatus(msg, danger){
    $("status").innerHTML = `<span class="${danger?"danger":"ok"}">${msg}</span>`;
  }

  function renderStock(){
    const wrap = $("stockWrap");
    wrap.innerHTML = "";
    state.stock.forEach((c,i)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.style.margin = "8px 0";

      const name = document.createElement("input");
      name.value = c.name;
      name.placeholder = "Couleur";
      name.style.width = "220px";
      name.oninput = ()=>{ state.stock[i].name = name.value; };

      const qty = document.createElement("input");
      qty.type="number"; qty.min="0"; qty.step="1";
      qty.value = c.qty;
      qty.placeholder="Rouleaux";
      qty.style.width="160px";
      qty.oninput = ()=>{ state.stock[i].qty = qty.value; };

      const del = document.createElement("button");
      del.textContent="Supprimer";
      del.className="danger";
      del.onclick = ()=>{
        const removed = state.stock[i]?.name;
        state.stock.splice(i,1);
        if(removed) delete state.pattern[removed];
        normalize(); save(); renderAll();
      };

      row.appendChild(name);
      row.appendChild(qty);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  function renderPattern(){
    const wrap = $("patternWrap");
    wrap.innerHTML = "";

    state.stock.forEach((c)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.style.margin = "8px 0";

      const label = document.createElement("div");
      label.style.width="220px";
      label.textContent = c.name;

      const val = document.createElement("input");
      val.type="number"; val.min="0"; val.step="1";
      val.value = state.pattern[c.name] ?? 0;
      val.placeholder="Par série";
      val.style.width="160px";
      val.oninput = ()=>{ state.pattern[c.name] = val.value; };

      row.appendChild(label);
      row.appendChild(val);
      wrap.appendChild(row);
    });

    const note = document.createElement("div");
    note.className="muted";
    note.style.marginTop="10px";
    note.innerHTML = "Astuce: Si une couleur ne doit pas être dans la série, mets 0.";
    wrap.appendChild(note);
  }

  function remainingStock(){
    const rem = {};
    state.stock.forEach(s=> rem[s.name] = Math.max(0, Math.floor(Number(s.qty)||0)));
    // retrancher les séries déjà générées
    state.series.forEach(sr=>{
      for(const [k,v] of Object.entries(sr.allocations)){
        rem[k] = Math.max(0, (rem[k] ?? 0) - v);
      }
    });
    return rem;
  }

  function total(rem){ return Object.values(rem).reduce((a,b)=>a+b,0); }

  function patternTotal(){
    return Object.values(state.pattern).reduce((a,b)=>a+Math.max(0,Math.floor(Number(b)||0)),0);
  }

  // ✅ coeur: répéter le patron jusqu’à épuisement total
  // - Série complète si toutes les couleurs du patron peuvent être prélevées
  // - Quand une couleur du patron est insuffisante, on met ce qu’il reste (0..pattern) et on continue
  // - On s’arrête seulement quand TOUTES les couleurs sont à 0
  function generateAll(){
    normalize();
    const patTot = patternTotal();
    if(patTot <= 0){
      setStatus("Ton patron de série est vide (tout à 0). Mets des valeurs > 0 dans le patron.", true);
      return;
    }

    // on part du stock restant (si séries existantes)
    let rem = remainingStock();

    // boucle sécurité
    const results = [];
    for(let guard=0; guard<10000; guard++){
      if(total(rem) === 0) break;

      const alloc = {};
      let takenAny = false;

      // appliquer le patron
      for(const color of Object.keys(state.pattern)){
        const need = Math.max(0, Math.floor(Number(state.pattern[color])||0));
        if(need === 0) continue;

        const avail = rem[color] ?? 0;
        const take = Math.min(avail, need);
        if(take > 0) takenAny = true;
        alloc[color] = take;      // peut être 0 si fini
        rem[color] = avail - take;
      }

      // Si aucune couleur du patron n’a pu être prise, ça veut dire:
      // - il reste du stock dans des couleurs qui ne sont PAS dans le patron (ou patron=0 pour elles)
      // => on fait une "série reste" avec tout ce stock (pour ne pas bloquer)
      if(!takenAny){
        const restAlloc = {};
        for(const [c,q] of Object.entries(rem)){
          if(q>0){ restAlloc[c]=q; rem[c]=0; }
        }
        results.push(restAlloc);
        break;
      }

      results.push(alloc);
    }

    // ajouter au state.series
    results.forEach(a=>{
      state.series.push({ index: state.series.length + 1, allocations: a });
    });

    save();
    renderAll();
    setStatus(`${results.length} série(s) générée(s) ✅ (jusqu’à épuisement total)`, false);
  }

  function allColorsUnion(){
    const set = new Set();
    state.stock.forEach(s=>set.add(s.name));
    Object.keys(state.pattern).forEach(k=>set.add(k));
    state.series.forEach(sr=>Object.keys(sr.allocations).forEach(k=>set.add(k)));
    return Array.from(set);
  }

  function renderList(){
    const el = $("list");
    if(state.series.length===0){
      el.innerHTML = `<div class="muted">Aucune série générée.</div>`;
      return;
    }
    el.innerHTML = state.series.map(sr=>{
      const parts = Object.entries(sr.allocations)
        .filter(([_,v])=> (Number(v)||0) > 0)
        .map(([k,v])=> `${k}: ${v}`)
        .join(" • ");
      const txt = parts.length ? parts : "<span class='muted'>Série vide</span>";
      return `<div style="margin:6px 0"><b>Série ${sr.index}</b> — ${txt}</div>`;
    }).join("");
  }

  function renderTable(){
    const t = $("table");
    if(state.series.length===0){
      t.innerHTML = `<tr><td class="muted">Aucune donnée.</td></tr>`;
      return;
    }
    const cols = allColorsUnion();
    let html = "<tr><th>Série</th>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "</tr>";

    state.series.forEach(sr=>{
      html += `<tr><td><b>${sr.index}</b></td>`;
      cols.forEach(c=>{
        html += `<td>${sr.allocations?.[c] ?? 0}</td>`;
      });
      html += "</tr>";
    });
    t.innerHTML = html;
  }

  function renderReste(){
    const rem = remainingStock();
    const cols = allColorsUnion();
    const t = $("restTable");
    let html = "<tr>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "<th>Total</th></tr><tr>";
    cols.forEach(c=> html += `<td>${rem[c] ?? 0}</td>`);
    html += `<td><b>${total(rem)}</b></td></tr>`;
    t.innerHTML = html;
  }

  function renderAll(){
    renderStock();
    renderPattern();
    renderList();
    renderTable();
    renderReste();
  }

  // Handlers
  $("addStock").onclick = ()=>{
    state.stock.push({name:"", qty:0});
    renderAll();
  };
  $("save").onclick = ()=>{
    normalize();
    save();
    renderAll();
    setStatus("Enregistré ✅", false);
  };
  $("reset").onclick = ()=>{
    localStorage.removeItem("series_rouleaux_v1");
    location.reload();
  };
  $("genAll").onclick = ()=> generateAll();
  $("clear").onclick = ()=>{
    state.series = [];
    save();
    renderAll();
    setStatus("Résultats effacés ✅", false);
  };

  // init
  load();
  normalize();
  renderAll();
</script>
</body>
</html>
