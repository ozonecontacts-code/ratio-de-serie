<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Séries Rouleaux</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:16px; max-width:980px}
    h1{font-size:20px;margin:0 0 10px}
    .muted{color:#666; font-size:13px}
    .card{border:1px solid #ddd; border-radius:14px; padding:12px; margin:12px 0}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    input,button{font-size:16px; padding:10px; border:1px solid #ccc; border-radius:10px}
    button{cursor:pointer}
    table{border-collapse:collapse; width:100%}
    th,td{border:1px solid #e6e6e6; padding:8px; text-align:center}
    th{background:#f7f7f7; position:sticky; top:0}
    .danger{color:#b00020}
    .ok{color:#0b6b2a}
  </style>
</head>
<body>
  <h1>Calcul de séries par rouleaux</h1>
  <div class="muted">
    Tu saisis uniquement le stock (rouleaux) par couleur. L’app calcule automatiquement le <b>patron</b> (la 1ère série),
    puis répète les séries jusqu’à épuisement. La dernière série peut être incomplète (3 couleurs, 2 couleurs, etc.).
  </div>

  <div class="card">
    <h3 style="margin:0 0 10px">1) Stock (rouleaux)</h3>
    <div class="row">
      <button id="addStock">+ Ajouter couleur</button>
      <button id="clearAll" class="danger">Vider tout</button>
    </div>
    <div id="stockWrap" style="margin-top:10px"></div>
    <div class="muted">Ex: Noir = 12 signifie 12 rouleaux Noir.</div>
  </div>

  <div class="card">
    <div class="row">
      <button id="genAll">Calculer les séries</button>
      <button id="clearResults">Effacer résultats</button>
    </div>
    <div id="status" style="margin-top:10px"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Patron automatique (1ère série)</h3>
    <div id="patternView" class="muted">—</div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Liste)</h3>
    <div id="list"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Résultat (Tableau)</h3>
    <div style="overflow:auto">
      <table id="table"></table>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Reste final</h3>
    <div style="overflow:auto">
      <table id="restTable"></table>
    </div>
  </div>

<script>
  const $ = (id)=>document.getElementById(id);

  // ✅ IMPORTANT: aucun historique, tu repars de zéro à chaque ouverture
  const state = {
    stock: [
      { name: "Noir", qty: 0 },
      { name: "Gris", qty: 0 },
      { name: "Kaki", qty: 0 },
      { name: "Beige", qty: 0 },
    ],
    series: [],
    pattern: null // {color: qty} calculée
  };

  function normalize(){
    state.stock = (state.stock||[])
      .map(x=>({ name:(x.name||"").trim(), qty: Math.max(0, Math.floor(Number(x.qty)||0)) }))
      .filter(x=>x.name.length>0);
  }

  function setStatus(msg, danger){
    $("status").innerHTML = `<span class="${danger?"danger":"ok"}">${msg}</span>`;
  }

  function renderStock(){
    const wrap = $("stockWrap");
    wrap.innerHTML = "";
    state.stock.forEach((c,i)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.style.margin = "8px 0";

      const name = document.createElement("input");
      name.value = c.name;
      name.placeholder = "Couleur";
      name.style.width = "240px";
      name.oninput = ()=>{ state.stock[i].name = name.value; };

      const qty = document.createElement("input");
      qty.type="number"; qty.min="0"; qty.step="1";
      qty.value = c.qty;
      qty.placeholder="Rouleaux";
      qty.style.width="160px";
      qty.oninput = ()=>{ state.stock[i].qty = qty.value; };

      const del = document.createElement("button");
      del.textContent="Supprimer";
      del.className="danger";
      del.onclick = ()=>{
        state.stock.splice(i,1);
        normalize();
        renderAll();
      };

      row.appendChild(name);
      row.appendChild(qty);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  function totalStock(obj){
    return Object.values(obj).reduce((a,b)=>a+(Number(b)||0),0);
  }

  // ✅ Patron automatique = 1ère série calculée ainsi :
  // - On prend uniquement les couleurs dont stock > 0
  // - On prend la plus petite quantité parmi ces couleurs (minStock)
  // - Patron = pour chaque couleur active : minStock
  // => Exemple: Noir 12, Gris 7, Kaki 3, Beige 20 -> minStock=3 -> Patron: 3 de chaque couleur active
  //
  // Si tu veux une autre règle (ex: limiter à 5 max), je te l’ajuste.
  function computeAutoPatternFromStock(){
    const active = state.stock.filter(s=>s.qty>0);
    if(active.length===0) return null;

    const minStock = Math.min(...active.map(x=>x.qty));
    const pat = {};
    active.forEach(x=> { pat[x.name] = minStock; });
    return pat;
  }

  function computeSeries(){
    normalize();
    state.series = [];
    state.pattern = null;

    const pat = computeAutoPatternFromStock();
    if(!pat){
      renderAll();
      setStatus("Ajoute au moins une couleur avec un stock > 0.", true);
      return;
    }
    state.pattern = pat;

    // Stock restant
    const rem = {};
    state.stock.forEach(s=> rem[s.name] = s.qty);

    // Boucle: on applique le patron, mais si une couleur n’a plus assez,
    // on prend ce qui reste (0..pat) et on continue jusqu’à épuisement total.
    for(let guard=0; guard<10000; guard++){
      if(totalStock(rem)===0) break;

      const alloc = {};
      let tookAny = false;

      for(const [color, need0] of Object.entries(pat)){
        const need = Math.max(0, Math.floor(Number(need0)||0));
        const avail = rem[color] ?? 0;
        const take = Math.min(avail, need);
        alloc[color] = take;     // peut être 0 si couleur finie
        rem[color] = avail - take;
        if(take>0) tookAny = true;
      }

      // Si plus rien n’est pris via le patron mais il reste du stock dans d’autres couleurs
      // (ex: tu as ajouté une couleur qui n’était pas active au moment du patron),
      // on met tout le reste dans une dernière série.
      if(!tookAny){
        const last = {};
        for(const [c,q] of Object.entries(rem)){
          if(q>0){ last[c]=q; rem[c]=0; }
        }
        state.series.push({index: state.series.length+1, allocations:last});
        break;
      }

      state.series.push({index: state.series.length+1, allocations:alloc});
    }

    renderAll();
    setStatus(`Séries calculées ✅ (${state.series.length})`, false);
  }

  function allColorsUnion(){
    const set = new Set();
    state.stock.forEach(s=>set.add(s.name));
    if(state.pattern) Object.keys(state.pattern).forEach(k=>set.add(k));
    state.series.forEach(sr=>Object.keys(sr.allocations||{}).forEach(k=>set.add(k)));
    return Array.from(set);
  }

  function renderPattern(){
    const el = $("patternView");
    if(!state.pattern){
      el.textContent = "—";
      return;
    }
    const parts = Object.entries(state.pattern).map(([k,v])=>`${k}: ${v}`).join(" • ");
    el.innerHTML = `<b>${parts}</b>`;
  }

  function renderList(){
    const el = $("list");
    if(state.series.length===0){
      el.innerHTML = `<div class="muted">Aucune série.</div>`;
      return;
    }
    el.innerHTML = state.series.map(sr=>{
      const parts = Object.entries(sr.allocations)
        .filter(([_,v])=> (Number(v)||0) > 0)
        .map(([k,v])=> `${k}: ${v}`)
        .join(" • ");
      const txt = parts.length ? parts : "<span class='muted'>Série vide</span>";
      return `<div style="margin:6px 0"><b>Série ${sr.index}</b> — ${txt}</div>`;
    }).join("");
  }

  function renderTable(){
    const t = $("table");
    if(state.series.length===0){
      t.innerHTML = `<tr><td class="muted">Aucune donnée.</td></tr>`;
      return;
    }
    const cols = allColorsUnion();
    let html = "<tr><th>Série</th>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "</tr>";

    state.series.forEach(sr=>{
      html += `<tr><td><b>${sr.index}</b></td>`;
      cols.forEach(c=>{
        html += `<td>${sr.allocations?.[c] ?? 0}</td>`;
      });
      html += "</tr>";
    });
    t.innerHTML = html;
  }

  function renderReste(){
    // recalcul du reste = stock initial - allocations
    const rem = {};
    state.stock.forEach(s=> rem[s.name] = s.qty);
    state.series.forEach(sr=>{
      for(const [c,v] of Object.entries(sr.allocations||{})){
        rem[c] = Math.max(0, (rem[c]??0) - (Number(v)||0));
      }
    });

    const cols = allColorsUnion();
    const t = $("restTable");
    let html = "<tr>";
    cols.forEach(c=> html += `<th>${c}</th>`);
    html += "<th>Total</th></tr><tr>";
    cols.forEach(c=> html += `<td>${rem[c] ?? 0}</td>`);
    html += `<td><b>${totalStock(rem)}</b></td></tr>`;
    t.innerHTML = html;
  }

  function renderAll(){
    renderStock();
    renderPattern();
    renderList();
    renderTable();
    renderReste();
  }

  // Handlers
  $("addStock").onclick = ()=>{
    state.stock.push({name:"", qty:0});
    renderAll();
  };

  $("clearAll").onclick = ()=>{
    state.stock = [];
    state.series = [];
    state.pattern = null;
    renderAll();
    setStatus("Tout vidé ✅", false);
  };

  $("genAll").onclick = ()=> computeSeries();

  $("clearResults").onclick = ()=>{
    state.series = [];
    state.pattern = null;
    renderAll();
    setStatus("Résultats effacés ✅", false);
  };

  // init
  normalize();
  renderAll();
</script>
</body>
</html>
